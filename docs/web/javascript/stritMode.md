# JS严格模式

## 严格模式的作用  
- 消除js语法中一些不合理，不严谨，不安全的问题，减少怪异行为，保证代码的运行安全  
- 提高编译器效率，提高运行效率  
## 启用严格模式  

>不支持严格模式的浏览器会把use strict当作字符串处理,高版本浏览器都支持use strict严格模式 

- 整个脚本启用严格模式，在顶部执行use strict  
- 在函数中使用严格模式，在函数第一行添加use strict  
- 在eval函数中使用严格模式，在头部添加'use strict'语句
  - eval("'use strict';var x = 43;")
- class内，默认开启严格模式
- 模块内默认开启严格模式

## 严格模式的结果

### 过失错误,由静默失败转成抛出异常
- 无法再意外创建全局变量  
- 使引起静默失败的赋值操作抛出异常。比如给NaN赋值，删除不可删除的属性，给不可写和只读属性赋值，给不可扩展对象添加新属性等，在非严格模式下都是静默失败，开发者很难发现错误。严格模式下，会抛出异常，很容易发现错误。  
- 对象属性名必须唯一。正常模式允许重名属性，最后的属性决定其属性值，当代码改变对象的属性值时，会改变第一个属性值，就会产生bug  
- 函数参数名唯一，否则报错  
- 禁止八进制数字语法。
-   
### 简化变量使用
- 禁用with。with会把块内的任何名称映射到传进来的对象的属性，这个虽然可以简化写法，但是如果这个对象没有这个属性，就会创建块内作用域变量，甚至全部变量，这一切都是在运行时决定的，还会产生性能问题。 
- eval不再为上层范围引入新变量。正常模式下，eval('val x = 43;')会创建一个变量x，如果已经有了一个变量x，就会引起问题，eval("'use strict';var x = 43;")，这样启用了严格模式，x只能在eval内部使用。严格模式还会把eval和arguments作为关键词，减少怪异行为  
- 禁止delete来删除声明的变量。例如 let x ;delete x，会报错  
- 禁止arguments和arguments.callee（指当前函数），对其读取和赋值都会报错  
### js运行更安全
- 通过this传递给一个函数的值不会被强制转成一个对象。console.assert(fun.bind(true)() === true);  
- 一部分字符变成了保留关键字。implements,interface,let,package,private,protected,public,static,yield。  
- 禁止不在脚本和函数层面上的函数声明。